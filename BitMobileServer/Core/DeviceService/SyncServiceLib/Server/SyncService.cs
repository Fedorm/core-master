// Copyright © Microsoft Corporation. All rights reserved.

// Microsoft Limited Permissive License (Ms-LPL)

// This license governs use of the accompanying software. If you use the software, you accept this license. If you do not accept the license, do not use the software.

// 1. Definitions
// The terms “reproduce,” “reproduction,” “derivative works,” and “distribution” have the same meaning here as under U.S. copyright law.
// A “contribution” is the original software, or any additions or changes to the software.
// A “contributor” is any person that distributes its contribution under this license.
// “Licensed patents” are a contributor’s patent claims that read directly on its contribution.

// 2. Grant of Rights
// (A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution or any derivative works that you create.
// (B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution in the software.

// 3. Conditions and Limitations
// (A) No Trademark License- This license does not grant you rights to use any contributors’ name, logo, or trademarks.
// (B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, your patent license from such contributor to the software ends automatically.
// (C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution notices that are present in the software.
// (D) If you distribute any portion of the software in source code form, you may do so only under this license by including a complete copy of this license with your distribution. If you distribute any portion of the software in compiled or object code form, you may only do so under a license that complies with this license.
// (E) The software is licensed “as-is.” You bear the risk of using it. The contributors give no express warranties, guarantees or conditions. You may have additional consumer rights under your local laws which this license cannot change. To the extent permitted under your local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular purpose and non-infringement.
// (F) Platform Limitation- The licenses granted in sections 2(A) & 2(B) extend only to the software or derivative works that you create that run on a Microsoft Windows operating system product.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.ServiceModel.Channels;
using System.IO;
using System.ServiceModel;
using System.ServiceModel.Activation;
using Microsoft.Synchronization.Data;
using Microsoft.Synchronization.Services.SqlProvider;
using System.Security.Permissions;

namespace Microsoft.Synchronization.Services
{
    /// <summary>
    /// Arguments for OnEndSyncRequest event
    /// </summary>
    public class OnEndSyncRequestEventArgs : EventArgs
    {
        private Message msg;

        /// <summary>
        /// Constructor of the event that is raised before processing a sync request.
        /// </summary>
        public OnEndSyncRequestEventArgs(Message msg)
        {
            this.msg = msg;
        }

        /// <summary>
        /// Access message argument
        /// </summary>
        public Message Msg
        {
            get { return msg; }
        }
    }

    // InstanceContextMode => Specifies the number of service instances available for handling calls that are contained in incoming messages.
    //
    // AspNetCompatibilityRequirements => 
    //      ASP.NET compatibility mode allows WCF services to use features such as identity impersonation.
    /// <summary>
    /// SyncService implementation. This class handles the incoming requests for sync.
    /// </summary>
    /// <typeparam name="T">Entities class that is auto-generated by the SyncSvcUtil.exe tool.</typeparam>
    [ServiceBehavior(InstanceContextMode = InstanceContextMode.PerCall),
        AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public abstract class SyncService<T> : MarshalByRefObject, IRequestHandlerProxy where T : class, new()
    {
        #region Private Members

        private HttpContextServiceHost _serviceHost;
        private Request _requestDescription;
        private IRequestProcessor _requestProcessor;
        private Message _outgoingMessage;

        private SyncServiceConfiguration _syncConfiguration;

        #endregion

        #region Constructor

        /// <summary>
        /// Static constructor.
        /// </summary>
        static SyncService()
        {
            // Ensure that <T> has the SyncScope attribute on it.
            //Note: Early validation check to fail quickly if things are not correct.
            if (!Attribute.IsDefined(typeof(T), typeof(SyncScopeAttribute)))
            {
                throw SyncServiceException.CreateInternalServerError(Strings.TemplateClassNotMarkedWithSyncScopeAttribute);
            }

            SyncServiceTracer.TraceVerbose("SyncService initialized!");
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Method that can be overridden in a derived class to execute custom code before
        /// performing diagnostic checks. If the method returns true, the diagnostics checks will be
        /// done else a HTTP 404 response is sent back to the caller.
        /// </summary>
        /// <returns><see cref="bool" /> indicating whether diagnostics checks should be performed or not.</returns>
        public virtual bool OnBeginDiagnosticRequest()
        {
            // Return true here. The overridden method (if it exists) will be called.
            // Otherwise continue with processing the request.
            return true;
        }

        #endregion

        #region IRequestHandler Members

        /// <summary>
        /// Process an incoming request and return a WCF Message class instance.
        /// </summary>
        /// <param name="messageBody">Message body</param>
        /// <returns>Instance of the WCF Message class</returns>
        /// 

        private Guid Logon(HttpContextServiceHost ctx, out string email)
        {
            String configName = ctx.Headers["configname"];
            String configVersion = ctx.Headers["configversion"];
            if (configName == null || configVersion == null)
                throw new Exception("Unknown client version");

//            resolution = ctx.Headers["resolution"] ?? "Default";

            email = null;

            String userId = ctx.Headers["userid"];
            if (!String.IsNullOrEmpty(userId))
                return new Guid(userId);
            else
            {
                NetworkCredential credential = null;
                if (!String.IsNullOrEmpty(ctx.UserName) && !String.IsNullOrEmpty(ctx.UserPassword))
                    credential = new NetworkCredential(ctx.UserName, ctx.UserPassword);

                if (credential == null)
                {
                    String username = ctx.Headers["username"];
                    String password = ctx.Headers["password"];
                    if (!String.IsNullOrEmpty(username) && !String.IsNullOrEmpty(password))
                    {
                        credential = new NetworkCredential(username, password);
                    }
                }

                if (credential == null)
                    throw new UnauthorizedAccessException("Invalid user name or password");

                return Common.Logon.GetUserId2(CurrentScope(), credential, configName, configVersion, out email);
            }
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// Call the initialize client user code and create a new sync blob with the clientId.
        /// </summary>
        private void InitializeNewClient(Guid userId, string resolution)
        {
            _requestDescription.ProviderParams = new List<SqlSyncProviderFilterParameterInfo>(_syncConfiguration.FilterParameters.Count);

            // Loop through the filter parameter configuration and create a list of parameters in the request description 
            // that also contains the value.
            //Note: A single query string parameter can be assigned to multiple tables.
            foreach (var filterParameter in _syncConfiguration.FilterParameters)
            {
                string value = null;
                if (filterParameter.QueryStringKey.Equals("userid"))
                    value = userId.ToString();
                else if (filterParameter.QueryStringKey.Equals("resolution"))
                    value = resolution;
                else
                    value = _serviceHost.GetQueryStringItem(filterParameter.QueryStringKey);
                _requestDescription.ProviderParams.Add(new SqlSyncProviderFilterParameterInfo
                                                            {
                                                                SqlParameterName = filterParameter.SqlParameterName,
                                                                QueryStringKey = filterParameter.QueryStringKey,
                                                                TableName = filterParameter.TableName,
                                                                Value = WebUtil.ChangeType(value, filterParameter.ValueType)
                                                            });
            }
        }

        /// <summary>
        /// This method tries to look up the service configuration from the MetadataCache.
        /// For the first request, there will be no item in the cache and so, an object of type
        /// SyncServiceConfiguration is created, initialized and added to the MetadataCache.
        /// </summary>
        private void CreateConfiguration(string scope)
        {
            Type serviceType = base.GetType();

            // Check if we already have a configuration for the service in the metadata cache.

            //MetadataCacheItem item = MetadataCache.TryLookup(serviceType);
            MetadataCacheItem item = MetadataCache.TryLookup(serviceType);

            if (null == item)
            {
                SyncTracer.Info("Creating SyncServiceConfiguration for service type {0}", serviceType);

                item = new MetadataCacheItem(serviceType);

                // Initialize the private member since it will then have default values.
                // In case of an error in the static initializer, we can refer to the default values
                // of configuration.
                _syncConfiguration = new SyncServiceConfiguration(typeof(T));

                // This will invoke the static initialization method.
                _syncConfiguration.Initialize(serviceType, scope);

                String conflictPolicy = Common.Logon.GetConflictPolicy(scope);
                if (!String.IsNullOrEmpty(conflictPolicy))
                {
                    String p = conflictPolicy.ToLower();
                    switch (p)
                    {
                        case "serverwins":
                            _syncConfiguration.SetConflictResolutionPolicy(ConflictResolutionPolicy.ServerWins);
                            break;
                        case "clientwins":
                            _syncConfiguration.SetConflictResolutionPolicy(ConflictResolutionPolicy.ClientWins);
                            break;
                        default:
                            throw new Exception("Invalid conflictPolicy value");
                    }
                }

                item.Configuration = _syncConfiguration;

                //MetadataCache.AddCacheItem(serviceType, item);
                MetadataCache.AddCacheItem(serviceType, item);

                SyncTracer.Info("SyncServiceConfiguration for service type {0} created successfully!", serviceType);
            }
            else
            {
                _syncConfiguration = item.Configuration;
            }

            // Invoke the testhook Initialize method. 
            // Note: This needs to be called regardless of whether we find the configuration in the 
            // cache or not because this is on a per request basis.
            _syncConfiguration.InvokeTestHookInitializeMethod(serviceType);
        }

        /// <summary>
        /// Create a new instance of the WCF Message class that has the correct content type (xml/json) and has a serialized
        /// instance of the SyncError class which is a representation of the error message.
        /// </summary>
        /// <param name="httpStatusCode">Status code to be used for the outgoing response.</param>
        /// <param name="errorDescription">A description of the error.</param>
        /// <returns>An instance of the WCF Message class that is sent as response.</returns>
        private Message CreateExceptionMessage(HttpContextServiceHost ctx, HttpStatusCode httpStatusCode, string errorDescription)
        {
            ctx.StatusCode = httpStatusCode;
            ctx.StatusDescription = (httpStatusCode == HttpStatusCode.InternalServerError ? Strings.InternalServerError : errorDescription);

            var error = new ServiceError { ErrorDescription = errorDescription };

            Message message;
            if (_syncConfiguration.SerializationFormat == SyncSerializationFormat.ODataJson)
            {
                message = Message.CreateMessage(MessageVersion.None, String.Empty, error, new DataContractJsonSerializer(typeof(ServiceError)));
                message.Properties.Add(WebBodyFormatMessageProperty.Name, new WebBodyFormatMessageProperty(WebContentFormat.Json));
            }
            else
            {
                message = Message.CreateMessage(MessageVersion.None, String.Empty, error, new DataContractSerializer(typeof(ServiceError)));
                message.Properties.Add(WebBodyFormatMessageProperty.Name, new WebBodyFormatMessageProperty(WebContentFormat.Xml));
            }

            var property = new HttpResponseMessageProperty { StatusCode = httpStatusCode };
            property.Headers.Add(HttpResponseHeader.ContentType, WebUtil.GetContentType(_serviceHost.GetOutputSerializationFormat(_syncConfiguration.SerializationFormat)));

            message.Properties.Add(HttpResponseMessageProperty.Name, property);

            return message;
        }

        private Message CreateExceptionMessage(HttpContextServiceHost ctx, Exception exception)
        {
            if(exceptionCodes.ContainsKey(exception.GetType()))
                return CreateExceptionMessage(ctx, exceptionCodes[exception.GetType()], exception.Message);
            else
                return CreateExceptionMessage(ctx, HttpStatusCode.InternalServerError, exception.Message);
        }

        /// <summary>Create a instance of <see cref="Message" /> from an exception. This is sent as the response.</summary>
        /// <param name="exception">Exception to process</param>
        /// <returns>An instance of <see cref="Message" /> class.</returns>
        private Message CreateMessageFromUnhandledException(HttpContextServiceHost ctx, Exception exception)
        {
            string exceptionMessage = WebUtil.GetExceptionMessage(exception);

            SyncServiceTracer.TraceError(exceptionMessage);

            return _syncConfiguration.UseVerboseErrors
                                   ? CreateExceptionMessage(ctx, HttpStatusCode.InternalServerError, exceptionMessage)
                                   : CreateExceptionMessage(ctx, HttpStatusCode.InternalServerError, Strings.InternalServerError);
        }

        private void ProcessSyncServiceException(HttpContextServiceHost ctx, SyncServiceException syncServiceException)
        {
            string exceptionMessage = WebUtil.GetExceptionMessage(syncServiceException);

            SyncServiceTracer.TraceWarning(exceptionMessage);

            _outgoingMessage = _syncConfiguration.UseVerboseErrors
                                   ? CreateExceptionMessage(ctx, (HttpStatusCode)syncServiceException.StatusCode, exceptionMessage)
                                   : CreateExceptionMessage(ctx, (HttpStatusCode)syncServiceException.StatusCode, syncServiceException.Message);

            // Add the "Allow" HTTP header if present._outgoingMessage.Properties[HttpResponseMessageProperty.Name].
            if (!String.IsNullOrEmpty(syncServiceException.ResponseAllowHeader) &&
                null != _outgoingMessage.Properties[HttpResponseMessageProperty.Name])
            {
                ((HttpResponseMessageProperty)_outgoingMessage.Properties[HttpResponseMessageProperty.Name]).
                    Headers.Add("Allow", syncServiceException.ResponseAllowHeader);
            }
        }

        #endregion

        #region Events

        /// <summary>
        /// Event that is raised before processing a sync request.
        /// </summary>
        public event EventHandler OnBeginSyncRequest;

        private void InvokeOnSyncRequestStart()
        {
            EventHandler request = OnBeginSyncRequest;
            if (request != null)
            {
                SyncTracer.Verbose("Raising OnBeginSyncRequest event");
                request(this, new EventArgs());
                SyncTracer.Verbose("Done: Raising OnBeginSyncRequest event");
            }
        }

        /// <summary>
        /// Event that is raised before writing the response to the caller.
        /// </summary>
        public event EventHandler<OnEndSyncRequestEventArgs> OnEndSyncRequest;

        private void InvokeOnEndSyncRequest(Message message)
        {
            EventHandler<OnEndSyncRequestEventArgs> request = OnEndSyncRequest;
            if (request != null)
            {
                SyncTracer.Verbose("Raising OnEndSyncRequest event");
                request(this, new OnEndSyncRequestEventArgs(message));
                SyncTracer.Verbose("Done: Raising OnEndSyncRequest event");
            }
        }

        #endregion


        public Stream ProcessRequest(HttpContextServiceHost ctx)
        {
            DateTime startTime = DateTime.Now;
            bool logged = false;
            Exception raisedException = null;
            try
            {
                try
                {
                    // Intialize the service host first, since most of the logic depends on it.
                    _serviceHost = ctx;// new HttpContextServiceHost(messageBody);
                    //_serviceHost.ValidateRequestHttpVerbAndSegments();

                    // Create the configuration. The first call will initialize the configuration
                    // and all other calls will be a no-op. 
                    CreateConfiguration(CurrentScope());

                    // Raise event for user code
                    InvokeOnSyncRequestStart();
                    _requestDescription = new RequestParser(_serviceHost, _syncConfiguration).ParseIncomingRequest();

                    string email;
                    Guid userId = Logon(ctx, out email);
                    ctx.UserId = userId.ToString();
                    ctx.UserEMail = email;

                    Common.Logon.CheckLicense(CurrentScope(), ctx.Headers["deviceId"]);
                    Common.Logon.CheckCoreVersion(CurrentScope(), ctx.Headers["coreversion"]);
                    ctx.ResourceVersion = Common.Logon.GetResourceVersion(CurrentScope());
                    
                    //add request parameters
                    _requestDescription.RequestParams = new Dictionary<string, object>();
                    _requestDescription.RequestParams.Add("@UserId", userId);

                    if (null == _requestDescription.SyncBlob || 0 == _requestDescription.SyncBlob.Length)
                    {
                        InitializeNewClient(userId, "Default");
                    }

                    _requestProcessor = RequestProcessorFactory.GetRequestProcessorInstance(_requestDescription.RequestCommand, _syncConfiguration, _serviceHost);

                    _outgoingMessage = _requestProcessor.ProcessRequest(_requestDescription);

                    // Add sync properties
                    var responseProperties = _outgoingMessage.Properties[HttpResponseMessageProperty.Name] as HttpResponseMessageProperty;
                    if (null != responseProperties)
                    {
                        responseProperties.Headers[SyncServiceConstants.SYNC_SERVICE_VERSION_KEY] = SyncServiceConstants.SYNC_SERVICE_VERSION_VALUE;
                        responseProperties.Headers[SyncServiceConstants.SYNC_SERVICE_USERID] = userId.ToString();
                    }

                    // Raise event for user code
                    InvokeOnEndSyncRequest(_outgoingMessage);
                }
                catch (SyncServiceException syncServiceException)
                {
                    raisedException = syncServiceException;
                    ProcessSyncServiceException(ctx, syncServiceException); //_outgoingMessage is set inside
                }
                catch (DbSyncException dbSyncException)
                {
                    raisedException = dbSyncException;
                    if (dbSyncException.Message.StartsWith("Cannot find a valid scope"))
                        _outgoingMessage = CreateExceptionMessage(ctx, HttpStatusCode.Conflict, dbSyncException.Message);
                    else
                        _outgoingMessage = CreateExceptionMessageEx(dbSyncException, ctx);
                }
                catch (Exception exception)
                {
                    if (WebUtil.IsFatalException(exception))
                    {
                        throw;
                    }

                    raisedException = exception;
                    if (_outgoingMessage == null)
                        _outgoingMessage = CreateExceptionMessageEx(exception, ctx);

                    if (_outgoingMessage == null)
                        _outgoingMessage = CreateMessageFromUnhandledException(ctx, exception);
                }

                return MessageToStream(_outgoingMessage, ctx);
            }
            finally
            {
                if (!logged)
                    logged = LogRequestInfo(startTime, ctx.Headers);
                if (raisedException != null)
                    LogException(raisedException);
                LogToDb(_requestDescription.RequestCommand, ctx, startTime, ctx.Headers, raisedException);
            }
        }

        private Message CreateExceptionMessageEx(Exception exception, HttpContextServiceHost ctx)
        {
            if (exceptionCodes.ContainsKey(exception.GetType()))
                return CreateExceptionMessage(ctx, exception);

            if (exception.InnerException != null)
                    return CreateExceptionMessage(ctx, exception.InnerException);
            else
                return null;
        }

        private Dictionary<Type, System.Net.HttpStatusCode> exceptionCodes = new Dictionary<Type, System.Net.HttpStatusCode>()
        {
            { typeof(Common.ConflictVersionException), HttpStatusCode.NotAcceptable },
            { typeof(UnauthorizedAccessException), HttpStatusCode.Unauthorized },
            { typeof(Common.LicenseException), HttpStatusCode.PaymentRequired },
            { typeof(Common.UnsupportedCoreException), HttpStatusCode.PreconditionFailed },
            { typeof(System.Data.SqlClient.SqlException), HttpStatusCode.InternalServerError }
        };

        private System.IO.Stream MessageToStream(Message message, HttpContextServiceHost ctx)
        {
            System.IO.Stream ms = new System.IO.MemoryStream();
            using (System.IO.Stream tempms = new System.IO.MemoryStream())
            {
                using (System.Xml.XmlWriter writer = System.Xml.XmlWriter.Create(tempms))
                {
                    message.WriteMessage(writer);
                    writer.Flush();
                }
                ctx.OriginalContentLength = (int)tempms.Length;
                tempms.Position = 0;

                /*
                using (System.IO.FileStream fs = new FileStream(@"d:\f1.xml", FileMode.CreateNew))
                {
                    tempms.CopyTo(fs);
                    fs.Flush();
                }
                tempms.Position = 0;
                */

                using (System.IO.Compression.GZipStream gzip = new System.IO.Compression.GZipStream(ms, System.IO.Compression.CompressionMode.Compress, true))
                {
                    tempms.CopyTo(gzip);
                }
            }
            ms.Position = 0;
            
            /*
            using (System.IO.FileStream fs = new FileStream(@"d:\f2.xml.zip", FileMode.CreateNew))
            {
                ms.CopyTo(fs);
                fs.Flush();
            }
            ms.Position = 0;
            */

            return ms;
        }

        private String CurrentScope()
        {
            return AppDomain.CurrentDomain.FriendlyName;
        }

        private void LogException(Exception e)
        {
            Common.Solution.LogException(CurrentScope(), "device", e);
        }

        private bool LogRequestInfo(DateTime startTime, WebHeaderCollection headers)
        {
            String msg = String.Format("StartTime:{1};Duration:{2}ms", startTime.ToShortDateString(), startTime.ToLongTimeString(), (DateTime.Now - startTime).TotalMilliseconds.ToString());
            foreach (String key in headers.Keys)
            {
                msg = msg + String.Format(";{0}:{1}", key, headers[key] == null ? "null" : headers[key]);
            }
            Common.Solution.Log(CurrentScope(), "device", msg);
            return true;
        }

        private void LogToDb(RequestCommand cmd, HttpContextServiceHost ctx, DateTime startTime, WebHeaderCollection headers, Exception e)
        {
            try
            {
                String statusDescription = ctx.StatusDescription;
                if(e!=null)
                {
                    statusDescription = e.Message;
                    while (e.InnerException != null)
                    {
                        statusDescription = statusDescription + "; " + e.InnerException.Message;
                        e = e.InnerException;
                    }
                }

                System.Collections.Generic.Dictionary<String, object> d = new Dictionary<string, object>();
                foreach (String key in headers.Keys)
                {
                    d.Add(key.ToLower().Replace("-", ""), headers[key]);
                }
                d.Add("StartTime".ToLower(), startTime);
                d.Add("EndTime".ToLower(), DateTime.Now);
                d.Add("Direction".ToLower(), (int)cmd);
                d.Add("Login".ToLower(), ctx.UserName);
                if(String.IsNullOrEmpty(ctx.UserId))
                    d.Add("UserId".ToLower(), null);
                else
                    d.Add("UserId".ToLower(), Guid.Parse(ctx.UserId));
                d.Add("UserEMail".ToLower(), ctx.UserEMail);
                d.Add("ResourceVersion".ToLower(), ctx.ResourceVersion);
                d.Add("OutputContentLength".ToLower(), ctx.OriginalContentLength);
                d.Add("StatusCode".ToLower(), (int)ctx.StatusCode);
                d.Add("StatusDescription".ToLower(), statusDescription);
                d.Add("FirstSync".ToLower(), (null == _requestDescription.SyncBlob || 0 == _requestDescription.SyncBlob.Length));

                Common.Logon.WriteLog(CurrentScope(), d);
            }
            catch
            {
            }
        }
    }

}
